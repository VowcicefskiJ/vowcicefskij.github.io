<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithms & Data Structures - CS 499 ePortfolio</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            min-height: 100vh;
        }
        
        header {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            padding: 2rem 0;
            text-align: center;
        }
        
        nav {
            background: #34495e;
            padding: 1rem 0;
            text-align: center;
        }
        
        nav a {
            color: white;
            text-decoration: none;
            margin: 0 1rem;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            transition: background 0.3s;
        }
        
        nav a:hover {
            background: #2c3e50;
        }
        
        main {
            padding: 2rem;
        }
        
        .section {
            margin-bottom: 2rem;
        }
        
        .section h2 {
            color: #2c3e50;
            border-bottom: 3px solid #e74c3c;
            padding-bottom: 0.5rem;
        }
        
        .highlight-box {
            background: #f8f9fa;
            border-left: 4px solid #e74c3c;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 5px 5px 0;
        }
        
        .enhancement-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }
        
        .enhancement-card {
            background: white;
            border: 1px solid #e1e8ed;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: transform 0.3s;
        }
        
        .enhancement-card:hover {
            transform: translateY(-3px);
        }
        
        .enhancement-card h4 {
            color: #2c3e50;
            margin-top: 0;
        }
        
        .complexity-badge {
            background: #e74c3c;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
            display: inline-block;
            margin: 0.5rem 0;
        }
        
        code {
            background: #f4f4f4;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }
        
        pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            border-left: 4px solid #e74c3c;
            font-size: 0.85rem;
            line-height: 1.4;
        }
        
        pre code {
            background: transparent;
            color: #ecf0f1;
            padding: 0;
        }
        
        .algorithm-stats {
            background: #ecf0f1;
            padding: 1rem;
            border-radius: 5px;
            margin: 1rem 0;
        }
        
        .algorithm-stats h5 {
            margin: 0 0 0.5rem 0;
            color: #2c3e50;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }
        
        .stat-item {
            text-align: center;
            padding: 0.5rem;
            background: white;
            border-radius: 5px;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #e74c3c;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #7f8c8d;
        }
        
        .algorithm-list {
            list-style: none;
            padding: 0;
        }
        
        .algorithm-list li {
            background: #f8f9fa;
            margin: 0.5rem 0;
            padding: 1rem;
            border-left: 4px solid #e74c3c;
            border-radius: 0 5px 5px 0;
        }
        
        .algorithm-list li strong {
            color: #e74c3c;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Algorithms & Data Structures</h1>
            <p>My Enhanced Numeric Overflow Detection Tool with Advanced Data Structures</p>
        </header>
        
        <nav>
            <a href="index.html">← Back to Portfolio</a>
            <a href="software-design.html">← Software Design</a>
            <a href="databases.html">Databases →</a>
        </nav>
        
        <main>
            <section class="section">
                <h2>My Project Overview</h2>
                <div class="highlight-box">
                    <p><strong>Original Project:</strong> CS 405 Basic Numeric Overflow Detection (C++)<br>
                    <strong>When I Made It:</strong> 2023<br>
                    <strong>What I Enhanced:</strong> Added advanced data structures, algorithms, and made it way more efficient</p>
                </div>
                
                <p>I started with this pretty basic C++ program from my CS 405 class that just checked if integers would overflow by comparing them to <code>INT_MAX</code> and <code>INT_MIN</code>. For my capstone project, I decided to completely transform it into something much more sophisticated by adding multiple data structures and optimization techniques I learned throughout my program.</p>
                
                <div class="algorithm-stats">
                    <h5>What I Achieved with Algorithm Complexity</h5>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-value">O(log n)</div>
                            <div class="stat-label">BST Search</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">O(log n)</div>
                            <div class="stat-label">Heap Operations</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">O(1)</div>
                            <div class="stat-label">DP Cache Access</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">O(n)</div>
                            <div class="stat-label">Tree Traversal</div>
                        </div>
                    </div>
                </div>
            </section>
            
            <section class="section">
                <h2>Data Structures I Implemented</h2>
                
                <div class="enhancement-grid">
                    <div class="enhancement-card">
                        <h4>Binary Search Tree</h4>
                        <span class="complexity-badge">O(log n) Search</span>
                        <p>I built my own BST from scratch to store and quickly find overflow events. It can do range searches and help me analyze patterns in the data.</p>
                    </div>
                    
                    <div class="enhancement-card">
                        <h4>Dynamic Programming Cache</h4>
                        <span class="complexity-badge">O(1) Access</span>
                        <p>I added a smart caching system that remembers overflow calculations so I don't have to compute the same things over and over. It really speeds things up!</p>
                    </div>
                    
                    <div class="enhancement-card">
                        <h4>Priority Queue (Heap)</h4>
                        <span class="complexity-badge">O(log n) Insert/Extract</span>
                        <p>I implemented a max-heap to automatically prioritize the most critical overflow events based on how severe they are.</p>
                    </div>
                    
                    <div class="enhancement-card">
                        <h4>Analytics Engine</h4>
                        <span class="complexity-badge">O(n) Pattern Analysis</span>
                        <p>I wrote algorithms to analyze patterns in the overflow data, like finding medians, looking at distributions, and spotting trends.</p>
                    </div>
                </div>
            </section>
            
            <section class="section">
                <h2>The Algorithms I Coded</h2>
                
                <h3>1. My Binary Search Tree Implementation</h3>
                <pre><code>class OverflowEventBST {
private:
    std::unique_ptr&lt;BST_Node&gt; root;
    
    std::unique_ptr&lt;BST_Node&gt; insert_recursive(
        std::unique_ptr&lt;BST_Node&gt; node, 
        const OverflowEvent& event
    ) {
        if (!node) {
            total_events++;
            return std::make_unique&lt;BST_Node&gt;(event);
        }
        
        if (event.event_id &lt; node-&gt;event.event_id) {
            node-&gt;left = insert_recursive(std::move(node-&gt;left), event);
        } else if (event.event_id &gt; node-&gt;event.event_id) {
            node-&gt;right = insert_recursive(std::move(node-&gt;right), event);
        }
        
        return node;
    }
    
public:
    // These give me O(log n) search speed
    OverflowEvent* search(long long event_id);
    std::vector&lt;OverflowEvent&gt; search_by_range(long long min_id, long long max_id);
    std::vector&lt;OverflowEvent&gt; search_by_severity(const std::string& severity);
};</code></pre>
                
                <h3>2. My Dynamic Programming Cache System</h3>
                <pre><code>class OverflowDP_Cache {
private:
    std::unordered_map&lt;std::string, 
        std::unordered_map&lt;std::string, long long&gt;&gt; boundary_cache;
    std::unordered_map&lt;std::string, int&gt; cache_hits;
    
public:
    long long get_overflow_boundary(const std::string& data_type, 
                                   const std::string& operation) {
        std::string cache_key = data_type + "_" + operation;
        
        // Super fast O(1) lookup if I've seen this before
        if (boundary_cache[data_type].find(operation) != 
            boundary_cache[data_type].end()) {
            cache_hits[cache_key]++;
            return boundary_cache[data_type][operation];
        }
        
        // If not, calculate it once and save it for next time
        long long boundary = calculate_boundary_dp(data_type, operation);
        boundary_cache[data_type][operation] = boundary;
        return boundary;
    }
};</code></pre>
                
                <h3>3. My Priority Queue with Custom Heap Operations</h3>
                <pre><code>class CriticalEventPriorityQueue {
private:
    std::vector&lt;OverflowEvent&gt; heap;
    
    void heapify_up(int index) {
        while (index &gt; 0 && 
               get_priority(heap[index]) &gt; get_priority(heap[parent(index)])) {
            std::swap(heap[index], heap[parent(index)]);
            index = parent(index);
        }
    }
    
    void heapify_down(int index) {
        int largest = index;
        int left = left_child(index);
        int right = right_child(index);
        
        if (left &lt; heap.size() && 
            get_priority(heap[left]) &gt; get_priority(heap[largest])) {
            largest = left;
        }
        
        if (right &lt; heap.size() && 
            get_priority(heap[right]) &gt; get_priority(heap[largest])) {
            largest = right;
        }
        
        if (largest != index) {
            std::swap(heap[index], heap[largest]);
            heapify_down(largest);
        }
    }
    
    int get_priority(const OverflowEvent& event) const {
        int base_priority = 0;
        if (event.severity == "CRITICAL") base_priority = 100;
        else if (event.severity == "HIGH") base_priority = 75;
        else if (event.severity == "MEDIUM") base_priority = 50;
        else base_priority = 25;
        
        return base_priority + (100 - event.steps_to_overflow);
    }
};</code></pre>
                
                <h3>4. My Template-Based Detection Engine</h3>
                <pre><code>template&lt;typename T&gt;
bool detect_and_analyze_overflow(T initial_value, T increment, 
                                int max_steps, const std::string& data_type) {
    // Using my DP cache to avoid recalculating boundaries
    long long boundary = dp_cache.get_overflow_boundary(data_type, "add");
    
    T current_value = initial_value;
    T safe_max = std::numeric_limits&lt;T&gt;::max();
    
    for (int step = 0; step &lt; max_steps; ++step) {
        // My improved overflow detection logic
        if (current_value &gt; safe_max - increment) {
            // Figure out how serious this overflow is
            std::string severity = determine_severity(step + 1, data_type);
            OverflowEvent event(next_event_id++, get_current_timestamp(), 
                              data_type, "OVERFLOW", 
                              static_cast&lt;long long&gt;(initial_value),
                              static_cast&lt;long long&gt;(increment),
                              static_cast&lt;long long&gt;(current_value),
                              step + 1, severity);
            
            // Store it in both my BST and priority queue
            event_tree.insert(event);
            priority_queue.insert(event);
            
            return true;
        }
        current_value += increment;
    }
    return false;
}</code></pre>
            </section>
            
            <section class="section">
                <h2>Pattern Analysis and Statistics</h2>
                
                <h3>My Statistical Analysis Code</h3>
                <p>I wrote this part to analyze patterns in overflow events using STL algorithms I learned about:</p>
                
                <pre><code>void analyze_overflow_patterns() {
    std::vector&lt;OverflowEvent&gt; all_events = event_tree.get_all_events_sorted();
    
    // I count different types of patterns
    std::unordered_map&lt;std::string, int&gt; severity_count;
    std::unordered_map&lt;std::string, int&gt; type_count;
    std::vector&lt;int&gt; steps_distribution;
    
    for (const auto& event : all_events) {
        severity_count[event.severity]++;
        type_count[event.data_type]++;
        steps_distribution.push_back(event.steps_to_overflow);
    }
    
    // Using STL algorithms for statistical calculations
    std::sort(steps_distribution.begin(), steps_distribution.end());
    double average_steps = std::accumulate(steps_distribution.begin(), 
                                          steps_distribution.end(), 0.0) / 
                          steps_distribution.size();
    
    int median = steps_distribution[steps_distribution.size() / 2];
}</code></pre>
                
                <h3>Performance Improvements I Made</h3>
                <ul>
                    <li><strong>Smart Memory Management:</strong> I used smart pointers so I don't have to worry about memory leaks</li>
                    <li><strong>Caching:</strong> My DP system means I never calculate the same thing twice</li>
                    <li><strong>Fast Searching:</strong> The BST gives me O(log n) speed even with lots of data</li>
                    <li><strong>Priority Processing:</strong> The heap automatically handles the most important events first</li>
                </ul>
            </section>
            
            <section class="section">
                <h2>How This Meets Course Outcomes</h2>
                
                <div class="enhancement-grid">
                    <div class="enhancement-card">
                        <h4>Course Outcome 3: Computing Solutions</h4>
                        <p>I implemented complex algorithms using BST, heap, and DP while learning how to balance performance trade-offs.</p>
                    </div>
                    
                    <div class="enhancement-card">
                        <h4>Course Outcome 4: Innovative Techniques</h4>
                        <p>I used advanced C++ features like templates, smart pointers, and STL algorithms to create professional-quality code.</p>
                    </div>
                    
                    <div class="enhancement-card">
                        <h4>Course Outcome 5: Security Mindset</h4>
                        <p>I focused on preventing buffer overflow vulnerabilities by building comprehensive detection and analysis systems.</p>
                    </div>
                </div>
            </section>
            
            <section class="section">
                <h2>What I Learned & How I Grew</h2>
                
                <h3>New Skills I Developed</h3>
                <ul>
                    <li><strong>Generic Programming:</strong> I figured out how to use templates to make my code work with different data types safely</li>
                    <li><strong>Data Structure Design:</strong> I learned how to build my own BST with custom search features</li>
                    <li><strong>Algorithm Optimization:</strong> I discovered how dynamic programming can make programs way faster</li>
                    <li><strong>Modern C++:</strong> I got comfortable with RAII principles and smart pointers</li>
                    <li><strong>Complexity Analysis:</strong> I learned how to think about time vs space trade-offs when designing algorithms</li>
                </ul>
                
                <h3>Challenges I Faced and Overcame</h3>
                <div class="highlight-box">
                    <p><strong>Template Confusion:</strong> Learning generic programming was tough - I had to understand how the compiler handles templates and type deduction.</p>
                    <p><strong>Memory Management:</strong> Building tree structures without memory leaks was tricky until I learned about unique_ptr and move semantics.</p>
                    <p><strong>Integrating Everything:</strong> Getting my BST, heap, and hash map to work together smoothly required careful planning of how they'd talk to each other.</p>
                    <p><strong>Performance vs Features:</strong> I had to learn when to prioritize speed versus adding cool features, and how caching could help with both.</p>
                </div>
                
                <div class="algorithm-stats">
                    <h5>Final Project Stats</h5>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-value">1,200+</div>
                            <div class="stat-label">Lines of Code</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">5</div>
                            <div class="stat-label">Data Structures</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">15+</div>
                            <div class="stat-label">Algorithms</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">Template</div>
                            <div class="stat-label">Generic Design</div>
                        </div>
                    </div>
                </div>
                
                <div class="highlight-box">
                    <p><strong>Why This Matters for My Career:</strong> This project taught me advanced algorithmic thinking, data structure design, and performance optimization—stuff that's super important for the kind of systems programming I want to do in robotics and embedded systems where efficiency and reliability are everything.</p>
                </div>
            </section>
            
            <section class="section">
                <h2>Download My Complete Code</h2>
                <div class="highlight-box">
                    <h3>My Advanced C++ Algorithm Project</h3>
                    <p><strong>Check out my complete C++ implementation:</strong></p>
                    
                    <div class="enhancement-grid">
                        <div class="enhancement-card">
                            <h4>Enhanced Overflow Detection System</h4>
                            <p>My complete C++ project with all the advanced data structures and optimizations I built</p>
                            <ul>
                                <li>Binary Search Tree Implementation</li>
                                <li>Dynamic Programming Cache</li>
                                <li>Priority Queue (Heap)</li>
                                <li>Template Programming</li>
                                <li>Smart Pointer Management</li>
                            </ul>
                            <a href="https://www.dropbox.com/scl/fi/45gcipcxj6ktpfgivcznb/NumericOverflowCPPProject.zip?rlkey=dyjbs9ov8p7tnpzwbiqhmrbde&st=lgbn1vpw&dl=0" 
                               class="btn" target="_blank">
                                📦 Download My C++ Project (ZIP)
                            </a>
                            <p><em>Includes all my C++ source code, headers, and the testing framework I wrote</em></p>
                        </div>
                    </div>
                </div>
            </section>
        </main>
    </div>
</body>
</html>
